namespace MalwareScan.AMSI
{
    using System;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;

    using static AmsiWrapper;

    /// <summary>
    /// Provides a wrapper for the AMSI interface on Windows 10+ and Windows Server 2016+
    /// <exception cref="AMSIException">May throw an AMSIException if any call to the AMSI interface fails unexpectedly.</exception>
    /// </summary>
    public class MalwareScanner : IDisposable
    {
        // This currently calls AmsiInitalise once for the whole class and then
        // opens a session for each call to the scanning service.
        // Need to do some performance testing to see if there is a benefit to sharing a session,
        // Maybe by passing in an array of streams or something?
        // ReSharper disable once InconsistentNaming
        
        // [SuppressMessage("StyleCop.CSharp.NamingRules", "SA1311:StaticReadonlyFieldsMustBeginWithUpperCaseLetter", Justification = "Reviewed. Suppression is OK here.")]
        // private static readonly ILog logger = LogProvider.For<MalwareScanner>();

        private readonly string appName = "MalwareScanner.AMSI";

        private readonly Lazy<IntPtr> amsiContextLazy;

        /// <summary>
        /// Initializes a new instance of the <see cref="MalwareScanner"/> class. 
        /// The instance will keep a reference to the OS malware scanning service, i.e.
        /// AmsiInitialize (https://msdn.microsoft.com/en-us/library/windows/desktop/dn889862(v=vs.85).aspx),
        /// which will be released on dispose or destruction.
        /// If malware is found, the application name 'MalwareScanner.AMSI' may appear in the system logs.
        /// </summary>
        public MalwareScanner() : this(String.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MalwareScanner"/> class. 
        /// The instance will keep a reference to the OS malware scanning service, i.e.
        /// AmsiInitialize (https://msdn.microsoft.com/en-us/library/windows/desktop/dn889862(v=vs.85).aspx),
        /// which will be release on dispose or destruction.
        /// </summary>
        /// <param name="applicationName">
        /// If specified, this application name is passed to Windows when scanning. Defaults to 'MalwareScanner.AMSI'.
        /// It may show up in logs, so if you pass in an application name, make sure it is clear that this is the deliberately 
        /// scanning part of your application to avoid the logs looking it is your application that is at fault.
        /// // For example 'MyApplications virus scanner'
        /// </param>
        public MalwareScanner(string applicationName)
        {
            if (!String.IsNullOrWhiteSpace(applicationName))
            {
                this.appName = applicationName;
            }

            this.amsiContextLazy = new Lazy<IntPtr>(
                () =>
                    {
                        IntPtr ctx;
                        int result;
                        try
                        {
                            // logger.Debug("Starting to initialise AMSI");
                            result = AmsiInitialize(this.appName, out ctx);
                        }
                        catch (Exception e)
                        {
                            // logger.Error(e, "Failed to initialise AMSI - aborting");
                            throw new AMSIException($"Failed to initialise AMSI (the first thing we do): {e.Message}. See the inner exception for more details.", e);
                        }

                        if (result != 0)
                        {
                            // logger.Error("AMSI Intialisation returned an unexpected result: {result}. Aborting.", result);
                            throw new AMSIException($"Failed to open an AMSI Session - the Initialise call returned {result}");
                        }

                        return ctx;
                    });
        }

        /// <summary>
        /// This will test an EICAR file to see if the virus is picked up.
        /// AMSI is only supported on Windows 10+ and on Server 2016 and you need to ensure a malware scanner that
        /// supports AMSI (such as windows defender) is installed and working.
        /// Don't call this function more often than you have to as the virus scan will be logged.
        /// For example, you may want to call it once on application startup 
        /// </summary>
        /// <returns>The IsItWorking property on the result will be True if malware scanning is working</returns>
        public MalwareScanTestResult TestIfItIsWorking()
        {
            // logger.Debug($"Starting {nameof(this.TestIfItIsWorking)}");
            int result;
            int scanResult;
            try
            {
                var context = this.amsiContextLazy.Value;
                var session = this.OpenSession();
                var teststring = @"X5O!P%@AP[4\PZX54(P^)7CC)7}" + @"$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*";
                var filename = "test-file-eicar.com";
                result = AmsiScanString(context, teststring, filename, session, out scanResult);
            }
            catch (Exception e)
            {
                // logger.Error(e, "The attempt to scan a test string failed with an exception");
                return new MalwareScanTestResult()
                    {
                        IsItWorking = false,
                        ErrorMessage = $"The attempt to scan a test string failed with an exception: {e.Message}",
                        Exception = e
                    };
            }

            if (result != 0)
            {
                // logger.Error("The attempt to scan a test string returned an unexpected result: {result}", result);
                return new MalwareScanTestResult()
                    {
                        IsItWorking = false,
                        ErrorMessage = $"The attempt to scan a test string returned an unexpected result: {result}. This is an HRESULT and is not clearly defined in AMSI."
                    };
            }

            if (HasMalware(scanResult))
            {
                // logger.Debug("Test was successful");
                return new MalwareScanTestResult() { IsItWorking = true };
            }

            // logger.Warn("The test scan of an EICAR string did not detect a virus. This indicates a virus scanner is not installed or working");
            return new MalwareScanTestResult()
                {
                    IsItWorking = false,
                    ErrorMessage = "The test scan of an EICAR string did not detect a virus. This indicates a virus scanner is not installed or working"
                };
        }

        /// <summary>
        /// Scans a stream for virus
        /// </summary>
        /// <param name="stream">
        /// If the stream supports seeking, such as, say, a MemoryStream or FileStream then this will work fine.
        /// The scanner will go back to the start and read to the end and reset the position back to wherever you had it.
        /// However, if you want to scan, say, the input stream in a web app then it may not be possible to rewind the stream,
        /// meaning you can't then access the stream content yourself after the scanner has read it.
        /// Similarly, the scanner can only read the stream from the point where it is when when you pass it in. 
        /// There are scenarios where that is fine, but usually you'd want to first copy the forward-only stream to a memory stream, 
        /// and then scan the memory stream. Don't forget to set the position to 0 before you start reading it yourself as the stream copy
        /// will leave it at the end of the stream.
        /// </param>
        /// <param name="filename">The name of the file. It is passed on to the virus scanner and *may* be used in determining scanning algorithms or it may be ignored - the AMSI documentation is not extensive.</param>
        /// <returns>true if the scanned content contains malware and should be blocked. Otherwise, false</returns>
        public bool HasVirus(Stream stream, string filename)
        {
            return this.HasVirus(CopyToByteArray(stream), filename);
        }

        /// <summary>
        /// Will scann the byte array for a virus.
        /// </summary>
        /// <param name="bytearray">A byte array with content you want scanned, usually the contents of a file.</param>
        /// <param name="filename">The name of the file. It is passed on to the virus scanner and *may* be used in determining scanning algorithms or it may be ignored - the AMSI documentation is not extensive.</param>
        /// <returns>True if a virus was detected, false in all other cases.</returns>
        public bool HasVirus(byte[] bytearray, string filename)
        {
            if (bytearray == null)
            {
                throw new ArgumentException("An null array is not valid", nameof(bytearray));
            }

            if (string.IsNullOrWhiteSpace(filename))
            {
                throw new ArgumentException("An empty filename is not allowed", nameof(filename));
            }

            if (bytearray.Length == 0)
            {
                // logger.Warn("You have passed in empty stream or array with the name {filename}. This usually indicates a problem with stream handling in your code. However, as it may be valid, the scanner will return a 'no virus found' result", filename);
                return false;
            }

            IntPtr session = IntPtr.Zero;
            
            try
            {
                session = this.OpenSession();
                var scanResult = this.Scan(bytearray, filename, session);
                // logger.Debug("Scan result for {filename}: {result}", filename, scanResult);
                var hasMalware = HasMalware(scanResult);

                if (hasMalware)
                {
                    // logger.Warn("{filename} was found to contain malware", filename);
                }
                else
                {
                    // logger.Debug("{filename} was not found to contain malware", filename);
                }

                return hasMalware;
            }
            finally
            {
                if (session != IntPtr.Zero)
                {
                    AmsiCloseSession(this.amsiContextLazy.Value, session);
                }
            }
        }

        public void Dispose()
        {
            this.ReleaseUnmanagedResources();
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Courtesy of https://stackoverflow.com/questions/1080442/how-to-convert-an-stream-into-a-byte-in-c
        /// </summary>
        /// <param name="stream">An input stream</param>
        /// <returns>A byte array</returns>
        private static byte[] CopyToByteArray(Stream stream)
        {
            // logger.Debug($"Starting {nameof(CopyToByteArray)}");
            long originalPosition = 0;

            if (stream.CanSeek)
            {
                originalPosition = stream.Position;
                stream.Position = 0;
            }

            try
            {
                byte[] readBuffer = new byte[4096];

                int totalBytesRead = 0;
                int bytesRead;

                while ((bytesRead = stream.Read(readBuffer, totalBytesRead, readBuffer.Length - totalBytesRead)) > 0)
                {
                    totalBytesRead += bytesRead;

                    if (totalBytesRead == readBuffer.Length)
                    {
                        int nextByte = stream.ReadByte();
                        if (nextByte != -1)
                        {
                            byte[] temp = new byte[readBuffer.Length * 2];
                            Buffer.BlockCopy(readBuffer, 0, temp, 0, readBuffer.Length);
                            Buffer.SetByte(temp, totalBytesRead, (byte)nextByte);
                            readBuffer = temp;
                            totalBytesRead++;
                        }
                    }
                }

                byte[] buffer = readBuffer;
                if (readBuffer.Length != totalBytesRead)
                {
                    buffer = new byte[totalBytesRead];
                    Buffer.BlockCopy(readBuffer, 0, buffer, 0, totalBytesRead);
                }

                // logger.Debug($"{nameof(CopyToByteArray)} returning");
                return buffer;
            }
            finally
            {
                if (stream.CanSeek)
                {
                    stream.Position = originalPosition;
                }
            }
        }

        /// <summary>
        /// This partially replicates the AmsiResultIsMalware which we can't seem to access (I suspect it just exist in the amsi.h file)
        /// and partially adds some specific handling for admin blocks.
        /// The scanresult is a risk rating and there may be some future requirement for looking at the number in more detail
        /// It probably should be refactored into a class so it can have some proper unit tests
        /// </summary>
        /// <param name="scanResult">The result of a scan</param>
        /// <returns>True if malware was detected</returns>
        private static bool HasMalware(int scanResult)
        {
            // See https://msdn.microsoft.com/en-us/library/windows/desktop/dn889584(v=vs.85).aspx
            // ReSharper disable InconsistentNaming
            // ReSharper disable UnusedVariable
            const int // AMSI_RESULT_CLEAN = 0,
                      // AMSI_RESULT_NOT_DETECTED = 1,
                      AMSI_RESULT_BLOCKED_BY_ADMIN_START = 16384,
                      AMSI_RESULT_BLOCKED_BY_ADMIN_END = 20479,
                      AMSI_RESULT_DETECTED = 32768;

            // ReSharper enable InconsistentNaming
            // ReSharper enable UnusedVariable
            if (scanResult >= AMSI_RESULT_DETECTED)
            {
                return true;
            }

            if (scanResult >= AMSI_RESULT_BLOCKED_BY_ADMIN_START && scanResult <= AMSI_RESULT_BLOCKED_BY_ADMIN_END)
            {
                // logger.Error("The AMSI scan result {result} indicates a problem with permissions on the machine. See https://msdn.microsoft.com/en-us/library/windows/desktop/dn889584(v=vs.85).aspx", scanResult);
                throw new AMSIException($"The admin policy on this machine does not allow you to scan. The value returned was {scanResult}. See https://msdn.microsoft.com/en-us/library/windows/desktop/dn889584(v=vs.85).aspx");
            }

            return false;
        }

        private int Scan(byte[] bytearray, string filename, IntPtr session)
        {
            // logger.Debug($"Starting {nameof(this.Scan)} for {{filename}}", filename);
            int result;
            var length = Convert.ToUInt32(bytearray.Length);
            int scanResult;
            try
            {
                result = AmsiScanBuffer(this.amsiContextLazy.Value, bytearray, length, filename, session, out scanResult);
            }
            catch (Exception e)
            {
                // logger.Error(e, "An unexpected error occured calling AmsiScanBuffer for {filename}", filename);
                throw new AMSIException(
                    $"An unexpected error occured calling AmsiScanBuffer: {e.Message}. See the inner exception for more details.",
                    e);
            }

            if (result != 0)
            {
                // logger.Error("An unexpected result (HRESULT): {result} was returned when calling AmsiScanBuffer for {filename}. Aborting.", result, filename);
                throw new AMSIException($"Failed to scan {filename}. The call to AmsiScanBuffer returned {result}.");
            }

            // logger.Debug($"{nameof(this.Scan)} is returning {{result}} for {{filename}}", scanResult, filename);
            return scanResult;
        }

        private IntPtr OpenSession()
        {
            // logger.Debug($"Starting {nameof(this.OpenSession)}");
            IntPtr session;
            int result;
            try
            {
                result = AmsiOpenSession(this.amsiContextLazy.Value, out session);
            }
            catch (Exception e)
            {
                // logger.Error(e, "Failed to open an AMSI Session. Aborting.");
                throw new AMSIException($"Failed to open an AMSI Session: {e.Message}. See the inner exception for details.", e);
            }

            if (result != 0)
            {
                // logger.Error("AMSI OpenSession returned an unexpected result: {result}. Aborting.", result);
                throw new AMSIException($"Failed to open an AMSI Session - the OpenSession call returned {result}");
            }

            return session;
        }

        private void ReleaseUnmanagedResources()
        {
            try
            {
                if (this.amsiContextLazy.IsValueCreated)
                {
                    AmsiUninitialize(this.amsiContextLazy.Value);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
        }

        ~MalwareScanner()
        {
            this.ReleaseUnmanagedResources();
        }
    }
}
